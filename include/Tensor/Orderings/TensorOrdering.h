//
// Created on 1/15/24.
//

#ifndef SPARSEVIZ_TENSORORDERING_H
#define SPARSEVIZ_TENSORORDERING_H

#include <stdexcept>
#include <string>
#include "config.h"
#include <iostream>
#include "SparseTensor.h"
#include <stdexcept>
#include <exception>
#include "KernelResult.h"
#include "GPUKernelResult.h"


/*!
 * @class TensorOrdering
 * @brief TensorOrdering is an abstract class from which every custom tensor ordering in the library is derived.
 * @details Handles various operations to assist users in focusing on their ordering algorithm, facilitating its integration into the SparseViz ecosystem.
 */
class TensorOrdering
{
public:
    /*!
     * @brief Constructor for the TensorOrdering class.
     * @param tensor Reference to the SparseTensor to be ordered.
     * @param active_modes Active modes of the tensor.
     * @param orderingName The name assigned to this particular ordering.
     * @param orderingFunctionPrice An integer from 0 to 10 representing the overhead of the ordering function that is dictated to be overridden by every custom ordering class. Defaults to 0, but specifying it is recommended to optimize program performance.
     */
    TensorOrdering(SparseTensor& tensor, const std::vector<vType>& active_modes, std::string orderingName, unsigned int orderingFunctionPrice = 0);

    /*!
     * @brief Copy Constructor is unavailable.
     */
    TensorOrdering(const TensorOrdering& other) = delete;

    /*!
     * @brief Copy Operator is unavailable.
     */
    TensorOrdering(const TensorOrdering&& other) = delete;

    /*!
     * @brief Move Constructor is unavailable.
     */
    TensorOrdering& operator=(const TensorOrdering& other) = delete;

    /*!
     * @brief Move Operator is unavailable.
     */
    TensorOrdering& operator=(const TensorOrdering&& other) = delete;

    /*!
     * @brief Destructor to clean up the allocated memory space.
     */
    virtual ~TensorOrdering();

    /*!
     * @brief Public method to execute the ordering function.
     * @param writeOrdering Flag to determine if the ordering should be written to a binary file. Defaults to true.
     * @details This method acts as a wrapper, handling various operations behind the scenes in addition to running the orderingFunction.
     * @see Some operations implemented under the hood are as following:
     * @see TensorOrdering::readOrdering
     * @see TensorOrdering::checkPermutationCorrectness
     * @see TensorOrdering::writeOrdering
     */
    void generateOrdering(bool writeOrdering = true);

    /*!
     * @brief Stores the result of a kernel executed on the tensor ordered by this object.
     * @param kernelResult The result of the kernel execution.
     */
    void pushKernelResult(const KernelResult& kernelResult);

    /*!
     * @brief Stores the result of a GPU kernel executed on the tensor ordered by this object.
     * @param gpuKernelResult The result of the GPU kernel execution.
     */
    void pushGPUKernelResult(const GPUKernelResult& kernelResult);

    // GETTERS
    [[maybe_unused]] [[nodiscard]] std::string getOrderingName() const {return orderingName;}
    [[maybe_unused]] [[nodiscard]] double getOrderingPrice() const {return orderingPrice;}
    [[maybe_unused]] [[nodiscard]] vType** getOrderedDimensions() const;
    [[maybe_unused]] [[nodiscard]] SparseTensor& getTensor();
    [[maybe_unused]] [[nodiscard]] const std::vector<KernelResult>& getKernelResults() const {return kernelResults;}
    [[maybe_unused]] [[nodiscard]] const std::vector<GPUKernelResult>& getGPUKernelResults() const {return gpuKernelResults;}
    [[maybe_unused]] [[nodiscard]] const std::vector<vType>& getActiveModes() const {return active_modes;}

protected:
    /*!
     * @brief Pure virtual function to define the ordering algorithm.
     * @details This function should be implemented in derived classes to specify the custom ordering logic.
     */
    virtual void orderingFunction() = 0;

protected:
    vType** orderedDimensions;    //!< This is a matrix, generated by orderingFunction. It maps the new locations of nonzero elements across each dimension. Initially, it is set to nullptr and should be properly initialized by the orderingFunction. Cleaning it up is not within the responsibilities of the custom ordering classes.
    std::string orderingName;
    double orderingPrice;
    const std::vector<vType> active_modes;
    SparseTensor& tensor;

private:
    /*!
     * @brief Calculates the ordering price based on certain parameters, such as the overhead that the orderingFunction and the properties that the current tensor has
     */
    void calculateOrderingPrice(unsigned int orderingFunctionPrice);

    /*!
     * @brief Checks whether or not the permutation arrays generated by the orderingFunction has some kind of logical errors in it.
     * @throws std::logic_error, if it detected that there is a logical error made during the construction of the permutation arrays.
     */
    void checkPermutationCorrectness();

    /*!
     * @brief Reads ordering from the binary file if it is detected that the current tensor ordering has been called on the same tensor and has been written to a binary file previously.
     */
    bool readOrdering();

    /*!
     * @brief Writes tensor ordering to a binary file to prevent calling the orderingFunction in the future.
     */
    void writeOrdering();

private:
    std::vector<KernelResult> kernelResults;
    std::vector<GPUKernelResult> gpuKernelResults;
};


#endif //SPARSEVIZ_TENSORORDERING_H
