<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://sparcityeu.github.io/sparseviz/addingCPUMatrixKernel/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Adding CPU Matrix Kernel - SparseViz</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Adding CPU Matrix Kernel";
        var mkdocs_page_input_path = "addingCPUMatrixKernel.md";
        var mkdocs_page_url = "/sparseviz/addingCPUMatrixKernel/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> SparseViz
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../configUse/">Config File</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">EXTENDING LIBRARY BEYOND</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../addingMatrixOrdering/">Adding Matrix Ordering</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../addingTensorOrdering/">Adding Tensor Ordering</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Adding CPU Matrix Kernel</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../addingGPUMatrixKernel/">Adding GPU Matrix Kernel</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../addingCPUTensorKernel/">Adding CPU Tensor Kernel</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../addingGPUTensorKernel/">Adding GPU Tensor Kernel</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../licence/">Licence</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">SparseViz</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">EXTENDING LIBRARY BEYOND</li>
      <li class="breadcrumb-item active">Adding CPU Matrix Kernel</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="tutorial-41-how-to-add-cpu-matrix-kernel">Tutorial 4.1: How to Add CPU Matrix Kernel</h1>
<p>SparseViz allows 2 types of matrix kernels to be added to the library
externally, CPU and GPU kernels. All CPU kernels can be written in
parallel using OpenMP. All GPU kernels, on the other hand, can be
written in parallel using Cuda. In this tutorial, we will analyze CPU
matrix kernels, especially how they can be added to the SparseViz
library.</p>
<p>All matrix kernels should be derived from the abstract class named
MatrixKernelFunction in the SparseViz library. This abstract class
provides various functionalities to ease the implementation of derived
classes aiming to provide kernels for sparse matrices.
MatrixKernelFunction dictates all its child classes to override 3 public
pure virtual functions to complete their implementation. These methods
are:</p>
<pre><code class="language-cpp">virtual bool init(const SparseMatrix&amp; A);
</code></pre>
<p>This method could be thought of as a constructor for the child class. It
is guaranteed that this method will be called before the execution of
every matrix kernel. The only difference it has with a traditional
constructor is that it is a boolean-returning function. In case there
are some circumstances in which user-defined matrix kernels are not
desired to be executed on some type of sparse matrices, it can easily be
programmed within that init method with a return value of "false" that
would eliminate the run of subsequent methods of the class, ultimately
leading to the termination of the execution of the kernel. One way to
use this functionality is if a user-defined kernel should be executed on
sparse matrices that are pattern symmetric, this check could be done in
the init function definition like so:</p>
<pre><code class="language-cpp">bool SequentialBFS::init(const SparseMatrix &amp;A)

{

    if (!A.isPatternSymmetric())

    {

        return false;

    }

}
</code></pre>
<p>This will guarantee that the kernel will never be executed on a matrix
without having pattern symmetry.</p>
<pre><code class="language-cpp">virtual void preprocess(const SparseMatrix&amp; A);
</code></pre>
<p>Matrix kernels could be executed from within the config file with a
specification of the number of iterations to be given as an argument.
This iteration number could be from 1 to many, depending on the user's
preference. This iteration and the for loop that enables it are
controlled by the base class MatrixKernelFunction. The preprocess method
comes into play at the very first method to be called upon at the start
of the iteration. In the implementation of this method, we give
opportunity to users to preprocess any data or data structures, be it
their initialization or their population, to be used during the current
iteration of the for loop. It is guaranteed that this preprocess will be
called as the first method in each iteration and the duration it took to
complete this method will never be reflected in the overall duration
kernel has taken to be executed. Because users cannot control the flow
of the matrix kernel execution and thus cannot pass any additional
parameters to the functionBody method - actual kernel function -, the
only way it can use the variables initialized in it is by declaring them
as member variables of the class to be used them in the actual kernel
function.</p>
<pre><code class="language-cpp">virtual void functionBody(const SparseMatrix&amp; A, int iterNumber);
</code></pre>
<p>As a last step user-defined child classes should complete their
implementation by providing the last pure virtual function a definition
that will carry out the actual logic of the matrix kernel. Within that
method, it is expected the users write the logic of the matrix kernel
that is executed on every ordered matrix indicated in the config file -
except ones that failed to proceed to this function because the init
method of the kernel returned false for them -. This function accepts an
additional integer parameter named iterNumber, which indicates the
number of consecutive times the functionBody has been called.</p>
<p>One important remark we need to make for our matrix kernel structure in
SparseViz is that during the execution of a kernel, all other threads
working for SparseViz process are temporarily stopped to be able to
provide all computational resources to the actual kernel execution and
to make experiments as realistic as possible.</p>
<p>Having learned each method we need to override in user-defined kernels
we can complete the declaration and the implementation of our kernel
named AddingCPUMatrixKernel under the directories
SparseViz/include/Kernel/Matrix/CPU and SparseViz/src/Kernel/Matrix/CPU,
respectively.</p>
<p><em>AddingCPUMatrixKernel.h</em></p>
<pre><code class="language-cpp">#include &quot;MatrixKernelFunction.h&quot;

class AddingCPUMatrixKernel: public MatrixKernelFunction

{

public:

    AddingCPUMatrixKernel(const std::string&amp; kernelName, const std::vector&lt;int&gt;&amp; threadCounts, const std::string&amp; schedulingPolicy, int chunkSize, int nRun, int nIgnore)
    :   MatrixKernelFunction(kernelName, threadCounts, schedulingPolicy, chunkSize, nRun, nIgnore) {}

    virtual ~AddingCPUMatrixKernel() override;

    virtual bool init(const SparseMatrix&amp; A) override;

    virtual void preprocess(const SparseMatrix&amp; A) override;

    virtual void functionBody(const SparseMatrix&amp; A, int iterNumber);

};
</code></pre>
<p>One extension we made for the class declaration on top of the 3 methods
that MatrixKernelFunction dictates its child class to override is the
virtual destructor. If anywhere during the init or in the preprocess
method you allocated memory on the heap or you made a process requiring
a cleanup (like opening a file or making a database connection), then in
the virtual destructor, it is also your responsibility to clean all them
up. Also, in the constructor that has an empty implementation, we did
not forget to initialize the parent class with the parameters provided
to the child class constructor. To remember what these parameters refer
to, you can do so by looking at tutorial 1, how to use the config file.</p>
<p><em>AddingCPUMatrixKernel.cpp</em></p>
<pre><code class="language-cpp">#include &quot;AddingCPUMatrixKernel.h&quot;

bool AddingCPUMatrixKernel::init(const SparseMatrix &amp;A)

{

    if (!A.isPatternSymmetric())

    {

        std::cout &lt;&lt; &quot;AddingCPUMatrixKernel is terminating: matrix needs to be pattern symmetric&quot; &lt;&lt; std::endl;

        return false;

    }

    // Your initialization code goes here.

    return true;

}

AddingCPUMatrixKernel::~AddingCPUMatrixKernel()

{

    // Your destructor code goes here.

}

void AddingCPUMatrixKernel::preprocess(const SparseMatrix&amp; A)

{

    // Your preprocess code goes here.

}

void AddingCPUMatrixKernel::functionBody(const SparseMatrix&amp; A, int iterNumber)

{

    // Your function body code goes here.

}
</code></pre>
<p>The remaining steps to integrate the matrix kernel into SparseViz
closely mirror those for adding matrix ordering. Initially, we must
incorporate our class declaration and implementation into the
CMakeLists.txt. Following this, we will introduce our matrix kernel
definition into the SparseVizEngine, enabling the library to recognize
and utilize this new kernel.</p>
<p><em>CMakeLists.txt</em></p>
<pre><code class="language-cpp">set(HEADER_FILES

    --- OTHER HEADER FILES (CROPPED) ---

    include/Kernel/Matrix/CPU/AddingCPUMatrixKernel.h

)

set(SOURCE_FILES

    --- OTHER SOURCE FILES (CROPPED) ---

    src/Kernel/Matrix/CPU/AddingCPUMatrixKernel.cpp

)
</code></pre>
<p><em>SparseVizEngine.h</em></p>
<pre><code class="language-cpp">#include &quot;AddingCPUMatrixKernel.h&quot;
</code></pre>
<p><em>SparseVizEngine.cpp</em></p>
<pre><code class="language-cpp">MatrixKernelFunction *SparseVizEngine::matrixKernelFactory(const std::string &amp;kernelName, const std::vector&lt;int&gt;&amp; threadCounts, const std::string &amp;schedulingPolicy, int chunkSize, int nRun, int nIgnore)

{

    --- OTHER KERNEL CLASSES (CROPPED) ---

    else if (kernelName == &quot;AddingCPUMatrixKernel&quot;)

    {

        return new AddingCPUMatrixKernel(kernelName, threadCounts, schedulingPolicy, chunkSize, nRun, nIgnore);

    }

    return nullptr;

}
</code></pre>
<p>Having made all of these steps, we can safely run our library with an
absolute path pointing to our config file in which we indicated our new
matrix kernel named AddingCPUMatrixKernel under the section
*MATRIX_KERNELS* to make it get executed on each ordered matrices,
like so:</p>
<p><em>config</em></p>
<pre><code class="language-cpp">*MATRIX_KERNELS*

AddingCPUMatrixKernel | WeHaveAddedACPUMatrixKernel | 1/2/4/6/8/16 | dynamic | 256 | 10 | 2
</code></pre>
<p>This concludes tutorial 4.1, the way to add CPU matrix kernels into the
library. In tutorial 4.2, its GPU counterpart will be explained.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../addingTensorOrdering/" class="btn btn-neutral float-left" title="Adding Tensor Ordering"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../addingGPUMatrixKernel/" class="btn btn-neutral float-right" title="Adding GPU Matrix Kernel">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../addingTensorOrdering/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../addingGPUMatrixKernel/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
